         Map<Integer, Integer> isFound = new HashMap<>();
                for(int i = 0; i<testedRecipe.getIngredients().size();i++){
                    Ingredient ingredient = testedRecipe.getIngredients().get(i);
                    Integer foundAt = null;
                    if(ingredient.isEmpty())
                        break;
                    for(int y = 0; y<inputInventory.getSlots();y++){

                        if(isFound.containsValue(y))
                            continue;

                        ItemStack stack = inputInventory.getItem(y);
                        if(ingredient.test(stack)){
                            foundAt = y;
                            break;
                        }
                    }
                    if(foundAt!=null){
                        isFound.put(i, foundAt);
                    } else doesntMatch = true;
                }
                //
                Map<Integer, Integer> isFluidFound = new HashMap<>();
                for(int i = 0; i<testedRecipe.getFluidIngredients().size();i++){
                    FluidIngredient ingredient = testedRecipe.getFluidIngredients().get(i);
                    Integer foundAt = null;
                    if(ingredient.getMatchingFluidStacks().isEmpty())
                        break;
                    for(int y = 0; y<inputInventory.getSlots();y++){

                        if(isFluidFound.containsValue(y))
                            continue;

                        FluidStack stack = inputTank.getPrimaryHandler().getFluidInTank(y);
                        if(ingredient.test(stack)){
                            foundAt = y;
                            break;
                        }
                    }
                    if(foundAt!=null){
                        isFluidFound.put(i, foundAt);
                    } else doesntMatch = true;
                }
                if(doesntMatch)
                    continue;
                //

                Map<net.minecraft.world.level.material.Fluid,Integer> fluids = new HashMap<>();

                List<FluidStack> totalFluidStacks = new ArrayList<>();

                for(int i = 0;i<outputTank.getPrimaryHandler().getTanks();i++){
                    totalFluidStacks.add(outputTank.getPrimaryHandler().getFluidInTank(i));
                }
                totalFluidStacks.addAll(testedRecipe.getFluidResults());

                for(FluidStack stack : totalFluidStacks){
                    if(stack.isEmpty())
                        continue;
                    if(fluids.containsKey(stack.getFluid())){
                        fluids.replace(stack.getFluid(),fluids.get(stack.getFluid())+stack.getAmount());
                    }else fluids.put(stack.getFluid(),stack.getAmount());

                }
                AtomicBoolean cantOutput= new AtomicBoolean(false);
                fluids.forEach((f,a)-> {
                    if(a>4000)
                        cantOutput.set(true);
                });

                //
                Map<Item,Integer> items = new HashMap<>();

                List<ItemStack> totalItemStacks = new ArrayList<>();

                for(int i = 0;i<outputInventory.getSlots();i++){
                    totalItemStacks.add(outputInventory.getStackInSlot(i));
                }
                totalItemStacks.addAll(testedRecipe.getRollableResultsAsItemStacks());

                for(ItemStack stack : totalItemStacks){
                    if(stack.isEmpty())
                        continue;
                    if(items.containsKey(stack.getItem())){
                        items.replace(stack.getItem(),items.get(stack.getItem())+stack.getCount());
                    }else items.put(stack.getItem(),stack.getCount());

                }
                items.forEach((f,a)-> {
                    if(a>64)
                        cantOutput.set(true);
                });
                if(cantOutput.get())
                    continue;